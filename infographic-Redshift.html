<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Complete Redshift Guide: Visuals, Tutorial & Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        main {
            flex-grow: 1;
        }
        /* Style for section titles */
        h2 {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 800; /* font-extrabold */
            color: #1e3a8a; /* blue-900 */
            margin-bottom: 2.5rem;
            text-align: center;
            padding-bottom: 1rem;
            border-bottom: 3px solid #93c5fd; /* blue-300 */
        }
        h3 {
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700;
            color: #1e40af; /* blue-800 */
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        h4 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 700;
            color: #1d4ed8; /* blue-700 */
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        .tutorial-content p {
            margin-bottom: 1rem;
            line-height: 1.75;
            color: #334155; /* slate-700 */
        }
        .tutorial-content ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            color: #334155;
        }
        .tutorial-content code {
            background-color: #e2e8f0; /* slate-200 */
            color: #1e293b; /* slate-800 */
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }
        .quiz-option {
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.2s;
        }
        .quiz-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        .quiz-option.correct {
            background-color: #dcfce7; /* green-100 */
            border-color: #22c55e; /* green-500 */
            color: #15803d; /* green-700 */
            font-weight: 600;
        }
        .quiz-option.incorrect {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
            color: #b91c1c; /* red-700 */
            font-weight: 600;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        .kpi-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            text-align: center;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .kpi-card:hover {
             transform: translateY(-5px);
             box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }
        .flow-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #1E40AF;
            margin: 0.5rem 0;
        }
        .hierarchy-box {
            border: 2px solid #1E40AF;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            background-color: #DBEAFE;
            color: #1E3A8A;
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <!-- Header and Navigation -->
    <header class="bg-blue-900 text-white shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center py-4">
                <div class="flex-shrink-0">
                    <h1 class="text-2xl md:text-3xl font-bold tracking-tight">The Complete Redshift Guide</h1>
                </div>
            </div>
            <!-- Tabs -->
            <div id="tabs-container" class="flex border-b border-blue-800">
                <button data-tab="general" class="tab-btn py-3 px-4 md:px-6 font-semibold border-b-2 border-white text-white">General Info</button>
                <button data-tab="advance" class="tab-btn py-3 px-4 md:px-6 font-semibold border-b-2 border-transparent text-blue-300 hover:text-white hover:border-blue-200 transition">Advance</button>
                <button data-tab="quiz" class="tab-btn py-3 px-4 md:px-6 font-semibold border-b-2 border-transparent text-blue-300 hover:text-white hover:border-blue-200 transition">Quiz</button>
            </div>
        </div>
    </header>

    <main class="container mx-auto px-4 py-12">
        <!-- General Info Tab Content -->
        <div id="general-content" class="tab-content">
            <section id="visuals">
                <h2 class="text-3xl font-bold text-blue-900 mb-8 text-center">A Visual Guide to the Cloud Data Warehouse</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center mb-12">
                    <div class="bg-white rounded-lg shadow-md p-6">
                        <h3 class="text-xl font-bold mb-4 text-center">OLAP vs OLTP Workloads</h3>
                        <p class="mb-4 text-gray-600">Redshift is an Online Analytical Processing (OLAP) system, optimized for a few complex queries on large datasets, unlike Online Transactional Processing (OLTP) systems which handle many small, frequent transactions.</p>
                        <div class="chart-container h-64 md:h-80">
                            <canvas id="olapVsOltpChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white rounded-lg shadow-md p-6">
                         <h3 class="text-xl font-bold mb-4 text-center">The Power of Columnar Storage</h3>
                        <p class="mb-4 text-gray-600">By storing data in columns instead of rows, Redshift dramatically reduces the amount of data read from disk for analytical queries, leading to significant speed improvements.</p>
                         <div class="chart-container h-64 md:h-80">
                            <canvas id="columnarStorageChart"></canvas>
                        </div>
                    </div>
                </div>
                 <div class="mt-8 bg-white rounded-lg shadow-md p-6 mb-12">
                    <h3 class="text-xl font-bold mb-6 text-center">Cluster Hierarchy: The Engine of Parallelism</h3>
                    <div class="flex flex-col items-center">
                        <div class="hierarchy-box w-full md:w-1/3">Leader Node</div>
                        <div class="flow-arrow">↓</div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 w-full">
                            <div class="hierarchy-box">Compute Node 1</div>
                            <div class="hierarchy-box">Compute Node 2</div>
                            <div class="hierarchy-box">Compute Node 3</div>
                        </div>
                        <div class="flow-arrow">↓</div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 w-full">
                             <div class="p-2 bg-blue-50 rounded-lg text-center"><div class="font-semibold text-blue-800">Slices</div><div class="text-xs text-blue-600">(Parallel Workers)</div></div>
                             <div class="p-2 bg-blue-50 rounded-lg text-center"><div class="font-semibold text-blue-800">Slices</div><div class="text-xs text-blue-600">(Parallel Workers)</div></div>
                             <div class="p-2 bg-blue-50 rounded-lg text-center"><div class="font-semibold text-blue-800">Slices</div><div class="text-xs text-blue-600">(Parallel Workers)</div></div>
                        </div>
                    </div>
                    <p class="mt-6 text-center text-gray-600">The Leader Node coordinates query execution across multiple Compute Nodes, which are further divided into Slices. This massively parallel architecture is the key to Redshift's performance.</p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
                    <div class="bg-white rounded-lg shadow-md p-6">
                        <h3 class="text-xl font-bold mb-4 text-center">Distribution Styles</h3>
                        <p class="mb-4 text-gray-600">Choosing the right distribution style is critical for minimizing data movement during joins. The style determines how table rows are physically placed across the cluster's slices.</p>
                        <div class="chart-container h-80">
                            <canvas id="distStylesChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white rounded-lg shadow-md p-6">
                        <h3 class="text-xl font-bold mb-4 text-center">Sort Keys & Zone Maps</h3>
                        <p class="mb-4 text-gray-600">Sort Keys physically order data on disk. Redshift then uses Zone Maps (metadata storing the min/max value per block) to instantly skip reading irrelevant data blocks, drastically speeding up queries.</p>
                        <div class="chart-container h-80">
                            <canvas id="sortKeysChart"></canvas>
                        </div>
                    </div>
                </div>
                 <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div class="kpi-card">
                        <h3 class="text-xl font-bold mb-2">Materialized Views</h3>
                        <p class="text-gray-600 mb-4">Pre-compute and store the results of complex queries to provide near-instant responses for dashboards and recurring reports.</p>
                        <div class="text-6xl font-black text-blue-600">10x</div>
                        <p class="font-semibold text-gray-700">Faster Dashboard Loads</p>
                    </div>
                    <div class="kpi-card">
                        <h3 class="text-xl font-bold mb-2">Data Sharing</h3>
                        <p class="text-gray-600 mb-4">Securely share live, read-only data between Redshift clusters (using RA3 nodes) without creating slow and costly data copies.</p>
                        <div class="text-6xl font-black text-blue-600">1</div>
                        <p class="font-semibold text-gray-700">Single Source of Truth</p>
                    </div>
                    <div class="kpi-card">
                        <h3 class="text-xl font-bold mb-2">Redshift Spectrum</h3>
                        <p class="text-gray-600 mb-4">Query petabytes of data directly in your Amazon S3 data lake without loading it into Redshift, joining it seamlessly with local tables.</p>
                        <div class="text-6xl font-black text-blue-600">∞</div>
                        <p class="font-semibold text-gray-700">Infinite Scale</p>
                    </div>
                </div>
            </section>
        </div>

        <!-- Advance Tab Content -->
        <div id="advance-content" class="tab-content hidden">
            <section id="tutorial" class="bg-white p-8 rounded-lg shadow-xl">
                <h2 id="tutorial-title">Advanced Performance Tuning Tutorial</h2>
                <div class="tutorial-content max-w-4xl mx-auto">
                    <p>This guide covers the advanced performance tuning concepts you'll need to optimize a real-world Redshift data warehouse. We will focus on the specific topics from the last quiz: Distribution Styles, Sort Keys, Materialized Views, and basic query plan analysis.</p>

                    <h3 id="dist-styles">1. Mastering Distribution Styles for Joins</h3>
                    <p>Choosing the right <code>DISTSTYLE</code> is the single most important factor for join performance. The goal is always to minimize data redistribution—the slow process of moving data between nodes over the network.</p>

                    <h4>Scenario 1: Joining Two Massive Tables</h4>
                    <ul>
                        <li><strong>Problem:</strong> You have a 10-billion-row <code>clicks</code> table and a 5-billion-row <code>conversions</code> table, and you frequently join them on <code>session_id</code>.</li>
                        <li><strong>Wrong Approach:</strong> <code>DISTSTYLE EVEN</code> on both. This would scatter both tables randomly, forcing Redshift to redistribute massive amounts of data to perform the join.</li>
                        <li><strong>Optimal Solution:</strong> <code>DISTSTYLE KEY (session_id)</code> on <strong>both</strong> tables.
                            <br><em>Why it works:</em> This strategy guarantees that all rows for the same <code>session_id</code> from both tables are physically stored on the same slice. The join becomes a local operation on each slice with zero data movement, which is incredibly fast.
                        </li>
                    </ul>

                    <h4>Scenario 2: Joining a Massive Table and a Small Table</h4>
                     <ul>
                        <li><strong>Problem:</strong> You have a 10-billion-row <code>events</code> table and a 200-row <code>country_codes</code> table, joined on <code>country_code</code>.</li>
                        <li><strong>Wrong Approach:</strong> <code>DISTSTYLE KEY</code> on both. While this works, there's a better way.</li>
                        <li><strong>Optimal Solution:</strong> <code>DISTSTYLE KEY (country_code)</code> on the large <code>events</code> table and <code>DISTSTYLE ALL</code> on the small <code>country_codes</code> table.
                            <br><em>Why it works:</em> <code>DISTSTYLE ALL</code> places a complete copy of the small table on every single compute node. This ensures that no matter how the large <code>events</code> table is distributed, the join will always be co-located and require no data movement. This is the standard best practice for small dimension tables.
                        </li>
                    </ul>

                    <h4>Scenario 3: A Large Standalone Table</h4>
                    <ul>
                        <li><strong>Problem:</strong> You have a massive log table that is analyzed on its own but is almost never joined to other tables.</li>
                        <li><strong>Optimal Solution:</strong> <code>DISTSTYLE EVEN</code>.
                            <br><em>Why it works:</em> Since there's no join key to optimize for, the primary goal is to ensure the data and the workload are spread perfectly evenly across all slices. <code>DISTSTYLE EVEN</code> does this by distributing rows in a round-robin fashion.
                        </li>
                    </ul>

                    <h3 id="sort-keys">2. Advanced Sort Key Strategy</h3>
                    <p>A <code>SORTKEY</code> physically orders data on disk, allowing Redshift to skip massive blocks of data.</p>
                    <h4>Compound Sort Keys and Column Order</h4>
                    <p>A <strong>Compound Sort Key</strong> is like a multi-level filing system. The order of the columns is critical.</p>
                    <ul>
                        <li><strong>Rule:</strong> The query optimizer can only effectively use the sort key to filter data if the <code>WHERE</code> clause includes the <strong>prefix</strong> (the first column) of the sort key.</li>
                        <li><strong>Example:</strong> Your table is defined with <code>COMPOUND SORTKEY (region, country)</code>. A query with <code>WHERE region = 'Asia'</code> will be very fast. A query with <code>WHERE country = 'Vietnam'</code> will be slow because it has to scan all regions.</li>
                    </ul>
                    <h4>Maintenance: <code>VACUUM</code> after Data Loads</h4>
                    <ul>
                        <li><strong>Problem:</strong> When you <code>COPY</code> new data into a table, it's stored in a separate, unsorted region. Over time, this makes your <code>SORTKEY</code> less effective, and queries become slower.</li>
                        <li><strong>Solution:</strong> Run the <code>VACUUM</code> command. It merges the new, unsorted data and re-sorts the entire table according to its <code>SORTKEY</code>.</li>
                    </ul>

                    <h3 id="mvs">3. Effective Use of Materialized Views</h3>
                    <p>Materialized Views store the pre-computed results of a query. They are a powerful tool, but must be used correctly.</p>
                    <h4>When to Use Them vs. When NOT to Use Them</h4>
                    <ul>
                        <li><strong>Use for:</strong> Predictable, recurring, and complex queries, like those that power a BI dashboard.</li>
                        <li><strong>Do NOT use for:</strong> Ad-hoc, exploratory queries that change constantly, as you can't pre-compute a result you don't know ahead of time.</li>
                    </ul>
                    <h4>Lifecycle: The <code>REFRESH</code> Command</h4>
                    <p>A Materialized View is a static snapshot. It does not update automatically. You must explicitly run <code>REFRESH MATERIALIZED VIEW my_view;</code> to update its data, otherwise it will serve stale results.</p>
                    <h4>Strategy: Materialize the Base, Not the Final Product</h4>
                    <ul>
                        <li><strong>Problem:</strong> A dashboard has three charts, all using slightly different aggregations from the same complex join.</li>
                        <li><strong>Wrong Approach:</strong> Creating three separate materialized views. This runs the expensive join three times.</li>
                        <li><strong>Optimal Solution:</strong> Create <strong>one</strong> materialized view that performs the expensive join. Then, the three fast, simple queries for the charts can all run against that small, pre-computed result.</li>
                    </ul>

                    <h3 id="explain">4. Reading an `EXPLAIN` Plan</h3>
                    <p>The <code>EXPLAIN</code> command shows you Redshift's query execution plan. Understanding it is key to finding bottlenecks.</p>
                    <ul>
                        <li><strong>Data Redistribution Steps:</strong> Look for steps that start with <code>DS_</code>. These indicate data is being moved across the network.</li>
                        <li><strong><code>DS_DIST_ALL_INNER</code>:</strong> This is a major red flag on large tables. It means the query planner decided to broadcast (send a full copy of) the entire inner table to all nodes to perform a join. This is extremely slow and indicates your distribution styles are likely incorrect for this query.</li>
                    </ul>
                </div>
            </section>
        </div>

        <!-- Quiz Tab Content -->
        <div id="quiz-content" class="tab-content hidden">
            <section id="quiz" class="bg-white p-8 rounded-lg shadow-xl">
                <h2>Test Your Knowledge</h2>
                <div id="quiz-container" class="max-w-4xl mx-auto">
                    <div id="quiz-start-screen">
                        <p class="text-lg mb-6 text-center text-slate-600">Ready to test your understanding of Redshift performance tuning? The quiz contains 20 questions drawn from the material above and general Redshift concepts. Questions and answers are shuffled each time.</p>
                        <button id="start-quiz-btn" class="w-full bg-blue-600 text-white font-bold py-4 px-6 rounded-lg hover:bg-blue-700 transition-all duration-200 text-xl shadow-lg hover:shadow-xl">Start Quiz</button>
                    </div>
                    <div id="quiz-question-screen" class="hidden">
                        <div class="flex justify-between items-center mb-4">
                            <p id="question-progress" class="text-sm font-semibold text-slate-500"></p>
                            <p id="quiz-score" class="text-sm font-semibold text-slate-500"></p>
                        </div>
                        <p id="question-text" class="text-2xl font-semibold mb-2"></p>
                        <p id="question-hint" class="text-sm text-slate-500 mb-6"></p>
                        <div id="answer-options" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
                        <button id="next-question-btn" class="hidden mt-8 w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors">Next Question</button>
                    </div>
                    <div id="quiz-results-screen" class="hidden text-center">
                        <h3 class="text-3xl font-bold mb-4">Quiz Complete!</h3>
                        <p class="text-6xl font-bold my-6 text-blue-800" id="final-score"></p>
                        <button id="restart-quiz-btn" class="w-full max-w-md mx-auto bg-blue-600 text-white font-bold py-4 px-6 rounded-lg hover:bg-blue-700 transition-colors text-xl">Try Again</button>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <footer class="text-center py-8 mt-12 bg-gray-800 text-gray-400">
        <p>&copy; 2025 The Complete Redshift Guide. All concepts derived from AWS documentation.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Chart.js setup from infographic ---
            const brilliantBlues = {
                background: 'rgba(219, 234, 254, 0.5)',
                primary: '#1E40AF',
                secondary: '#3B82F6',
                accent: '#93C5FD',
                text: '#1E3A8A'
            };
            
            const tooltipTitleCallback = {
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                const item = tooltipItems[0];
                                let label = item.chart.data.labels[item.dataIndex];
                                return Array.isArray(label) ? label.join(' ') : label;
                            }
                        }
                    }
                }
            };

            if (document.getElementById('olapVsOltpChart')) {
                new Chart(document.getElementById('olapVsOltpChart'), {
                    type: 'bar',
                    data: {
                        labels: ['OLTP (Transactional)', 'OLAP (Analytical)'],
                        datasets: [{
                            label: 'Query Complexity',
                            data: [2, 10],
                            backgroundColor: brilliantBlues.secondary,
                            borderColor: brilliantBlues.primary,
                            borderWidth: 2
                        }, {
                            label: 'Number of Queries',
                            data: [10, 3],
                            backgroundColor: brilliantBlues.accent,
                            borderColor: brilliantBlues.secondary,
                            borderWidth: 2
                        }]
                    },
                    options: { ...tooltipTitleCallback, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'Relative Scale' }}}, plugins: { ...tooltipTitleCallback.plugins, title: { display: true, text: 'Typical Workload Comparison' }}}
                });
            }
            
            if (document.getElementById('columnarStorageChart')) {
                new Chart(document.getElementById('columnarStorageChart'), {
                    type: 'doughnut',
                    data: {
                        labels: ['Data Read (Columnar)', 'Data Skipped (Columnar)', 'Data Read (Row-Based)'],
                        datasets: [{ data: [15, 85, 100], backgroundColor: [brilliantBlues.primary, brilliantBlues.background, brilliantBlues.secondary], label: 'Dataset' }]
                    },
                    options: { ...tooltipTitleCallback, maintainAspectRatio: false, plugins: { ...tooltipTitleCallback.plugins, title: { display: true, text: 'Data I/O for a Single Column Query' }, tooltip: { ...tooltipTitleCallback.plugins.tooltip, callbacks: { ...tooltipTitleCallback.plugins.tooltip.callbacks, label: (c) => `${c.label}: ${c.parsed}% of total table data` }}}}
                });
            }
            
            if (document.getElementById('distStylesChart')) {
                new Chart(document.getElementById('distStylesChart'), {
                    type: 'pie',
                    data: {
                        labels: ['KEY (For Frequent Joins)', 'EVEN (General Purpose)', 'ALL (Small Dimension Tables)'],
                        datasets: [{ label: 'Use Case Distribution', data: [50, 35, 15], backgroundColor: [brilliantBlues.primary, brilliantBlues.secondary, brilliantBlues.accent]}]
                    },
                    options: { ...tooltipTitleCallback, maintainAspectRatio: false, plugins: { ...tooltipTitleCallback.plugins, title: { display: true, text: 'Common Distribution Strategy' }, tooltip: { ...tooltipTitleCallback.plugins.tooltip, callbacks: { ...tooltipTitleCallback.plugins.tooltip.callbacks, label: (c) => `${c.label}: ${c.parsed}% of use cases` }}}}
                });
            }

            if (document.getElementById('sortKeysChart')) {
                new Chart(document.getElementById('sortKeysChart'), {
                    type: 'line',
                    data: {
                        labels: ['Unsorted Table', 'Table with SORTKEY'],
                        datasets: [{ label: 'Data Blocks Scanned for Query', data: [100, 5], fill: true, borderColor: brilliantBlues.primary, backgroundColor: brilliantBlues.background, tension: 0.1 }]
                    },
                    options: { ...tooltipTitleCallback, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: '% of Total Blocks' }}}, plugins: { ...tooltipTitleCallback.plugins, title: { display: true, text: 'Impact of SORTKEY on Query Scans' }}}
                });
            }

            // --- Tab logic ---
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.dataset.tab;

                    // Update button styles
                    tabButtons.forEach(btn => {
                        btn.classList.remove('border-white', 'text-white');
                        btn.classList.add('border-transparent', 'text-blue-300');
                    });
                    button.classList.add('border-white', 'text-white');
                    button.classList.remove('border-transparent', 'text-blue-300');

                    // Show/hide content
                    tabContents.forEach(content => {
                        if (content.id === `${tabName}-content`) {
                            content.classList.remove('hidden');
                        } else {
                            content.classList.add('hidden');
                        }
                    });
                });
            });


            // --- Quiz logic setup from study guide ---
            const quizData = [
                // Quiz 1 Questions
                { question: "A company needs to analyze five years of sales data to identify quarterly trends. The queries are complex and involve large aggregations. Which AWS service is designed specifically for this type of OLAP workload?", hint: "Consider the difference between databases designed for frequent, small transactions versus those designed for large, complex analytical queries.", options: [{ text: "Amazon RDS for PostgreSQL", isCorrect: false }, { text: "Amazon DynamoDB", isCorrect: false }, { text: "Amazon Redshift", isCorrect: true }, { text: "Amazon S3", isCorrect: false }] },
                { question: "In the Redshift cluster architecture, which component is responsible for parsing an incoming SQL query, developing an execution plan, and coordinating the parallel work among the other nodes?", hint: "Think about the hierarchy of a team. Who receives the project requirements and delegates the tasks to the workers?", options: [{ text: "Compute Node", isCorrect: false }, { text: "Slice", isCorrect: false }, { text: "Leader Node", isCorrect: true }, { text: "Redshift Spectrum", isCorrect: false }] },
                { question: "What is the most efficient and recommended method for bulk-loading a large dataset into a Redshift table?", hint: "Redshift is highly optimized to load data in parallel from a specific, scalable AWS storage service.", options: [{ text: "Running thousands of individual INSERT statements.", isCorrect: false }, { text: "Using the COPY command from an Amazon S3 bucket.", isCorrect: true }, { text: "Loading data directly from an on-premises server.", isCorrect: false }, { text: "Using a federated query to pull data from another database.", isCorrect: false }] },
                { question: "How does Redshift efficiently execute a query like `SELECT * FROM logs WHERE event_time > '2025-01-01'` on a petabyte-sized table without performing a full table scan?", hint: "Think about how you'd find a specific topic in a large, well-organized book. You wouldn't read every page; you'd use the index and chapter headings.", options: [{ text: "By using a materialized view for the logs table.", isCorrect: false }, { text: "By running the query on a Redshift Serverless environment.", isCorrect: false }, { text: "By using Zone Maps and a SORTKEY on `event_time`.", isCorrect: true }, { text: "By caching the entire table in the leader node's memory.", isCorrect: false }] },
                { question: "After deleting millions of old records from a large table, a developer notices that the table still consumes the same amount of disk space. What command should be run to reclaim this space?", hint: "When you delete files on a computer, they often go to a 'Recycle Bin' or 'Trash' and still take up space until you empty it. This command is the Redshift equivalent.", options: [{ text: "REFRESH MATERIALIZED VIEW", isCorrect: false }, { text: "ANALYZE", isCorrect: false }, { text: "ALTER TABLE", isCorrect: false }, { text: "VACUUM DELETE ONLY", isCorrect: true }] },
                { question: "A company wants to implement Redshift Data Sharing between its primary cluster in `us-east-1` and a reporting cluster in `eu-west-1`. What is a mandatory prerequisite for both clusters to enable this feature?", hint: "Data Sharing relies on a modern Redshift architecture that separates compute from storage.", options: [{ text: "Both clusters must be using the Redshift Serverless option.", isCorrect: false }, { text: "Both clusters must be using RA3 nodes.", isCorrect: true }, { text: "Both clusters must have Workload Management (WLM) disabled.", isCorrect: false }, { text: "Both clusters must have the exact same number of nodes.", isCorrect: false }] },
                { question: "You need to maintain a full history of how customer addresses change over time in a `customers` table. When a customer moves, the old address must be preserved and queryable. What is the standard data warehousing methodology for this?", hint: "This modeling technique involves adding new rows for changes instead of overwriting old data, often using date columns to track the version.", options: [{ text: "Creating a new table for each month.", isCorrect: false }, { text: "Relying on daily Redshift snapshots.", isCorrect: false }, { text: "Implementing Slowly Changing Dimensions (SCD) Type 2.", isCorrect: true }, { text: "Using a Lambda UDF to store history in DynamoDB.", isCorrect: false }] },
                { question: "A small startup has an intermittent need for data analytics. They run heavy queries for a few hours at the end of each month but have almost no usage otherwise. Which Redshift option would be the most cost-effective for this workload?", hint: "The key here is the variable and infrequent workload. The ideal solution would not charge for compute resources when they are not being used.", options: [{ text: "A large, provisioned RA3 cluster.", isCorrect: false }, { text: "Redshift Serverless", isCorrect: true }, { text: "A provisioned DC2 cluster.", isCorrect: false }, { text: "Using Redshift Spectrum exclusively.", isCorrect: false }] },
                { question: "An analytics dashboard has three different charts, all powered by slightly different aggregations from the same complex query joining `clicks` and `conversions`. The dashboard is slow to load. What is the most effective way to optimize this?", hint: "Instead of running a similar heavy calculation three times, consider calculating the common base data once and storing it.", options: [{ text: "Create three separate Materialized Views, one for each chart.", isCorrect: false }, { text: "Create one Materialized View of the joined base data, then query it for each chart.", isCorrect: true }, { text: "Increase the cluster size using Elastic Resize.", isCorrect: false }, { text: "Use Redshift Data Sharing to create a consumer cluster for the dashboard.", isCorrect: false }] },
                { question: "A query frequently filters a `transactions` table on `customer_id` and then sorts the results by `transaction_date`. Which SORTKEY definition would be most effective for this query?", hint: "The order of columns in a compound sort key matters. The key is most effective when your query filters on the prefix of the key.", options: [{ text: "SORTKEY (transaction_date)", isCorrect: false }, { text: "SORTKEY (transaction_date, customer_id)", isCorrect: false }, { text: "INTERLEAVED SORTKEY (customer_id, transaction_date)", isCorrect: false }, { text: "COMPOUND SORTKEY (customer_id, transaction_date)", isCorrect: true }] },
                { question: "You have a massive event log table that is primarily analyzed by `session_id` to understand user journeys. This table is almost never joined to other large tables. What is the best distribution style for this table?", hint: "If a table isn't frequently joined on a specific key, distributing it based on that key might not provide a benefit over simply spreading the data evenly.", options: [{ text: "DISTSTYLE KEY (session_id)", isCorrect: false }, { text: "DISTSTYLE ALL", isCorrect: false }, { text: "DISTSTYLE EVEN", isCorrect: true }, { text: "DISTSTYLE AUTO", isCorrect: false }] },
                { question: "A team created a materialized view to power their daily sales report. However, they complain that the report is showing yesterday's data, even though the underlying `sales` table was updated this morning. What is the most likely cause?", hint: "A materialized view is a physical snapshot of data at a point in time. It does not update itself automatically.", options: [{ text: "The materialized view needs to be dropped and recreated.", isCorrect: false }, { text: "There is a network issue preventing the view from accessing the base table.", isCorrect: false }, { text: "The materialized view has not been refreshed since the base table was updated.", isCorrect: true }, { text: "The user querying the view does not have the correct permissions on the base table.", isCorrect: false }] },
                { question: "You see a `DS_DIST_ALL_INNER` step in an `EXPLAIN` plan for a query that joins two very large tables. What does this indicate about the query's performance?", hint: "The `DS_DIST` prefix indicates data redistribution. Consider what it means to redistribute an entire large table to all nodes.", options: [{ text: "The query is highly optimized because the join is co-located.", isCorrect: false }, { text: "The query is performing poorly because one of the large tables is being broadcast to all nodes.", isCorrect: true }, { text: "The query is efficient because it is using a SORTKEY to filter data.", isCorrect: false }, { text: "The query is using Redshift Spectrum to access data in S3.", isCorrect: false }] },
                { question: "A table is defined with `SORTKEY (region, country)`. A query is run with the filter `WHERE country = 'Vietnam'`. How effectively will the sort key be used to prune data blocks?", hint: "A compound sort key is like a filing system sorted first by cabinet, then by folder. Can you efficiently find a specific folder if you don't know which cabinet it's in?", options: [{ text: "It will be fully effective, as `country` is part of the sort key.", isCorrect: false }, { text: "It will not be effective, as the query does not filter on the first column of the compound key.", isCorrect: true }, { text: "It will be partially effective, as Redshift can scan the zone maps for the second column.", isCorrect: false }, { text: "The effectiveness depends on the table's distribution style, not the sort key.", isCorrect: false }] },
                { question: "In which scenario would creating a materialized view be a POOR choice for performance optimization?", hint: "Materialized views are ideal for predictable, recurring queries. Consider a workload that is the opposite of that.", options: [{ text: "A BI dashboard that is refreshed by hundreds of users every morning.", isCorrect: false }, { text: "A nightly ETL job that summarizes daily data into an aggregate table.", isCorrect: false }, { text: "An environment where data analysts run ad-hoc, exploratory queries that change constantly.", isCorrect: true }, { text: "A query that provides data for a critical, real-time alerting system.", isCorrect: false }] },
                { question: "A data architect is designing a schema with a 10-billion-row `events` table and a 200-row `country_codes` table. The tables are frequently joined on `country_code`. What is the optimal distribution style for the small `country_codes` table?", hint: "For joins between a very large table and a very small one, you can avoid data movement entirely by placing a full copy of the small table everywhere it's needed.", options: [{ text: "DISTSTYLE EVEN", isCorrect: false }, { text: "DISTSTYLE KEY on `country_code`", isCorrect: false }, { text: "DISTSTYLE ALL", isCorrect: true }, { text: "DISTSTYLE AUTO", isCorrect: false }] },
                { question: "After loading a large batch of new data into a table with a defined `SORTKEY`, analysts report that queries that filter on the sort key column are now slower. What command should be run to restore performance?", hint: "New data is stored in an unsorted region. This command is the housekeeping utility that re-sorts the entire table.", options: [{ text: "ANALYZE", isCorrect: false }, { text: "VACUUM", isCorrect: true }, { text: "CREATE TABLE AS (CTAS)", isCorrect: false }, { text: "REFRESH MATERIALIZED VIEW", isCorrect: false }] },
                { question: "Two massive tables, `clicks` and `conversions` (both billions of rows), are frequently joined on `session_id`. What is the optimal distribution strategy to ensure the best join performance?", hint: "To avoid redistributing billions of rows across the network, you need to ensure that rows with the same `session_id` from both tables are physically stored on the same slice.", options: [{ text: "DISTSTYLE EVEN on both tables.", isCorrect: false }, { text: "DISTSTYLE ALL on both tables.", isCorrect: false }, { text: "DISTSTYLE KEY on `session_id` for both tables.", isCorrect: true }, { text: "DISTSTYLE KEY on `clicks` and DISTSTYLE EVEN on `conversions`.", isCorrect: false }] },
                { question: "You have a large fact table (`sales`) and a smaller dimension table (`users`). You frequently join them on `user_id`. To achieve the best query performance, which distribution style should you apply?", hint: "The goal is to place the joining rows on the same physical slice to avoid moving data across the network during a join.", options: [{ text: "DISTSTYLE EVEN on both tables.", isCorrect: false }, { text: "DISTSTYLE ALL on the large `sales` table and DISTSTYLE KEY on the `users` table.", isCorrect: false }, { text: "DISTSTYLE KEY on `user_id` for the `sales` table and DISTSTYLE ALL for the `users` table.", isCorrect: true }, { text: "DISTSTYLE KEY on `user_id` for both tables.", isCorrect: false }] }
            ];

            const startScreen = document.getElementById('quiz-start-screen');
            const questionScreen = document.getElementById('quiz-question-screen');
            const resultsScreen = document.getElementById('quiz-results-screen');
            const startBtn = document.getElementById('start-quiz-btn');
            const nextBtn = document.getElementById('next-question-btn');
            const restartBtn = document.getElementById('restart-quiz-btn');
            const questionProgress = document.getElementById('question-progress');
            const quizScoreEl = document.getElementById('quiz-score');
            const questionText = document.getElementById('question-text');
            const questionHint = document.getElementById('question-hint');
            const answerOptionsContainer = document.getElementById('answer-options');
            const finalScoreEl = document.getElementById('final-score');

            let shuffledQuestions = [];
            let currentQuestionIndex = 0;
            let score = 0;

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function startQuiz() {
                startScreen.classList.add('hidden');
                resultsScreen.classList.add('hidden');
                questionScreen.classList.remove('hidden');

                shuffledQuestions = [...quizData];
                shuffleArray(shuffledQuestions);
                currentQuestionIndex = 0;
                score = 0;
                
                displayQuestion();
            }

            function displayQuestion() {
                resetState();
                const currentQuestion = shuffledQuestions[currentQuestionIndex];
                questionText.textContent = currentQuestion.question;
                questionHint.textContent = `Hint: ${currentQuestion.hint}`;
                questionProgress.textContent = `Question ${currentQuestionIndex + 1} of ${shuffledQuestions.length}`;
                quizScoreEl.textContent = `Score: ${score}`;

                const shuffledOptions = [...currentQuestion.options];
                shuffleArray(shuffledOptions);

                shuffledOptions.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.classList.add('quiz-option', 'w-full', 'p-4', 'text-left', 'border-2', 'border-slate-300', 'rounded-lg', 'hover:bg-blue-100', 'hover:border-blue-400');
                    button.dataset.correct = option.isCorrect;
                    button.addEventListener('click', selectAnswer);
                    answerOptionsContainer.appendChild(button);
                });
            }
            
            function resetState() {
                nextBtn.classList.add('hidden');
                while (answerOptionsContainer.firstChild) {
                    answerOptionsContainer.removeChild(answerOptionsContainer.firstChild);
                }
            }

            function selectAnswer(e) {
                const selectedBtn = e.target;
                const isCorrect = selectedBtn.dataset.correct === 'true';

                if (isCorrect) {
                    score++;
                    selectedBtn.classList.add('correct');
                } else {
                    selectedBtn.classList.add('incorrect');
                }

                Array.from(answerOptionsContainer.children).forEach(button => {
                    if (button.dataset.correct === 'true') {
                        button.classList.add('correct');
                    }
                    button.disabled = true;
                });
                
                quizScoreEl.textContent = `Score: ${score}`;
                nextBtn.classList.remove('hidden');
            }

            function showNextQuestion() {
                currentQuestionIndex++;
                if (currentQuestionIndex < shuffledQuestions.length) {
                    displayQuestion();
                } else {
                    showResults();
                }
            }

            function showResults() {
                questionScreen.classList.add('hidden');
                resultsScreen.classList.remove('hidden');
                finalScoreEl.textContent = `${score} / ${shuffledQuestions.length}`;
            }

            startBtn.addEventListener('click', startQuiz);
            nextBtn.addEventListener('click', showNextQuestion);
            restartBtn.addEventListener('click', startQuiz);
        });
    </script>

</body>
</html>
